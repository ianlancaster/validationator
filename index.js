const getFuncParamNames=(a)=>{const b=/(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,)]*))/mg,c=/([^\s,]+)/g,d=a.toString().replace(b,'');let e=d.slice(d.indexOf('(')+1,d.indexOf(')')).match(c);return'{'===e[0]&&e['}'===e.length-1]&&(e=e.slice(1,-1)),null===e&&(e=[]),e},includesAnyTest=(a,b,c={})=>{let d=!1;c.ignoreCase&&(a=a.toLowerCase()),c.stringify&&(a=JSON.stringify(a));for(let e,f=0;f<b.length;f++)if(e=b[f],c.ignoreCase&&(e=e.toLowerCase()),c.stringify&&(e=JSON.stringify(e)),a.includes(e)){d=!0;break}return d},matchesAny=(a,b)=>{let c=!1;return b.forEach((b)=>{b===a&&(c=!0)}),c},validator=require('validator'),validationsMaster={array:(a,{maxLen:b,minLen:c,allChildren:d,children:e,includes:f,notIncludes:g,includesAny:h,notIncludesAny:i,name:j})=>{if(!Array.isArray(a))throw new Error(`Expected ${j}: ${a} to be type array. Got ${typeof a}.`);if(c&&a.length<c)throw new Error(`Array ${j}: ${a} length is ${a.length}. Less than minimum ${c}.`);if(b&&a.length>b)throw new Error(`Array ${j}: ${a} is ${a.length}. More than maximum ${b}.`);if(f&&!JSON.stringify(a).includes(JSON.stringify(f)))throw new Error(`Array ${j}: ${a} does not include required string: ${f}.`);if(g&&JSON.stringify(a).includes(JSON.stringify(g)))throw new Error(`Array ${j}: ${a} includes blacklisted string: ${g}.`);if(h&&!includesAnyTest(a,h,{stringify:!0}))throw new Error(`Array ${j}: ${a} does not include required string from: ${h}.`);if(i&&includesAnyTest(a,i,{stringify:!0}))throw new Error(`Array ${j}: ${a} includes blacklisted string from: ${i}.`);if(d&&a.forEach((b,c)=>{d.name=d.name||c,validate(a[c],d)}),e){if(!Array.isArray(e))throw new Error(`${j}: ${a}. Children must be an array. Got type ${typeof e}.`);e.forEach((b,c)=>{'string'==typeof b&&(b={type:b}),b.name=b.name||c,validate(a[c],b)})}},function:(a,{name:b})=>{if('function'!=typeof a)throw new Error(`Expected ${b}: ${a} to be type function. Got ${typeof a}.`)},object:(a,{requiredKeys:b,children:c,minLen:d,maxLen:e,allChildren:f,includes:g,notIncludes:h,includesAny:i,notIncludesAny:j,name:k,isInstance:l})=>{const m=Object.keys(a);if(('object'!=typeof a||Array.isArray(a))&&!l)throw new Error(`Expected ${k}: ${a} to be type object. Got type ${typeof a}. Array.isArray? ${Array.isArray(a)}.`);if(g&&!JSON.stringify(a).includes(JSON.stringify(g)))throw new Error(`Object ${k}: ${a} does not include required string: ${g}.`);if(h&&JSON.stringify(a).includes(JSON.stringify(h)))throw new Error(`Object ${k}: ${a} includes blacklisted string: ${h}.`);if(d&&m.length<d)throw new Error(`Object ${k}: ${a} length is ${m.length}. Less than minimum ${d}.`);if(e&&m.length>e)throw new Error(`Object ${k}: ${a} length is ${m.length} more than maximum ${e}.`);if(i&&!includesAnyTest(a,i,{stringify:!0}))throw new Error(`Object ${k}: ${a} does not include required string from: ${i}.`);if(j&&includesAnyTest(a,j,{stringify:!0}))throw new Error(`Object ${k}: ${a} includes blacklisted string from: ${j}.`);if(f&&m.forEach((b)=>validate(a[b],f,{name:b})),b&&b.forEach((b)=>{if(!m.find((a)=>a===b))throw new Error(`${k}: ${a} missing required key: ${b}.`)}),c){if('object'!=typeof c||Array.isArray(c))throw new Error(`Expected ${k}: ${a} validation children to be type object. Got type ${typeof a} Array.isArray? ${Array.isArray(a)}.`);const b=Object.keys(c);b.forEach((b)=>{let d=c[b];d.name=d.name||b,validate(a[b],d)})}},string:(a,b)=>{const{maxLen:c,minLen:d,regEx:e,includes:f,notIncludes:g,includesAny:h,notIncludesAny:i,name:j}=b;if('string'!=typeof a)throw new Error(`Expected ${j}: ${a} to be type string. Got type ${typeof a}.`);if(d&&a.length<d)throw new Error(`String "${j}: ${a}" length is ${a.length}. Less than minimum ${d}.`);if(c&&a.length>c)throw new Error(`String "${j}: ${a}" length is ${a.length}. more than maximum.`);if(e&&!e.test(a))throw new Error(`String "${j}: ${a}" does not match the validation regEx ${e}.`);if(f&&!a.includes(f))throw new Error(`String "${j}: ${a}" does not include required string: ${f}.`);if(g&&a.includes(g))throw new Error(`String "${j}: ${a}" includes blacklisted string: ${g}.`);if(h&&!includesAnyTest(a,h))throw new Error(`String "${j}: ${a}" does not include any required string from: [${h}].`);if(i&&includesAnyTest(a,i))throw new Error(`String "${j}: ${a}" includes a blacklisted string from: [${i}].`);if('upperCase'in b&!validator.isUppercase(a))throw new Error(`String: ${j}: ${a} is not uppercase!`);if('lowerCase'in b&!validator.isLowercase(a))throw new Error(`String: ${j}: ${a} is not lowercase!`)},number:(a,{max:b,min:c,decimals:d,regEx:e,name:f})=>{if('number'!=typeof a)throw new Error(`Expected ${f}: ${a} to be type number. Got ${typeof a}.`);if(c&&a<c)throw new Error(`Number ${f}: ${a} is less than minimum ${c}.`);if(b&&a>b)throw new Error(`Number ${f}: ${a} is more than maximum ${b}.`);if(e&&!e.test(a))throw new Error(`Number ${f}: ${a} does not match regEx ${e}.`);let g;if('undefined'!=typeof d&&(()=>{const b=a.toString().split('.');if(b[1])return g=b[1].length,g>d})())throw new Error(`Number: ${a} has ${g} decimals. More than max ${d}.`)},boolean:(a,{name:b})=>{if('boolean'!=typeof a)throw new Error(`Expected ${b}: ${a} to be type boolean. Got ${typeof a}.`)},bool:(a,{name:b})=>{if('boolean'!=typeof a)throw new Error(`Expected ${b}: ${a} to be type boolean. Got ${typeof a}.`)},instance:(a,b)=>{const{of:c}=b;if(!c||'function'!=typeof c)throw new Error(`Instance validation for ${a} failed. Must provide constructor through the "of" option.`);if('strict'in b){if(a.constructor!==c)throw new Error(`value: ${a} is not a strict instance of ${c}`);}else if(!(a instanceof c))throw new Error(`value: ${a} is not an instance of ${c}`);validate(a,Object.assign({},b,{type:Object,isInstance:!0}))},email:(a,b)=>{if(validate(a,'string'),!validator.isEmail(a,b))throw new Error(`string: ${a} does not match email validation with options: ${b}`)},is:(a,{exactly:b})=>{if(typeof a!=typeof b||JSON.stringify(a)!==JSON.stringify(b))throw new Error(`value: ${a} is not exactly equal to ${b}`)},"string-int":(a,b)=>{validate(parseInt(a),Object.assign(b,{type:'number',name:'string-int'}))},"postal-code":(a,{state:b})=>{if(validate(a,['string','number']),b=b||'any',a=`${a}`,!validator.isPostalCode(a,b))throw new Error(`value: ${a} is not a valid postal code ${b?` for state ${b}`:''}`)},url:(a,b)=>{if(validate(a,'string'),!validator.isURL(a,b))throw new Error(`URL ${a} did not match the validation: ${b}`)},date:(a)=>{if(!validator.toDate(a))throw new Error(`value: ${a} is not a valid date`)},"date-obj":(a)=>{if(validate(a,'object'),'[object Date]'!==Object.prototype.toString.call(a))throw new Error(`value: ${a} is not a valid date object`)},phone:(a,{mobile:b})=>{validate(a,['string','number']),a=`${a}`,validate(a,{type:'string',name:'phone',regEx:/^\s*(?:\+?(\d{1,3}))?[-. (]*(\d{3})[-. )]*(\d{3})[-. ]*(\d{4})(?: *x(\d+))?\s*$/}),!0===b&&(b='any'),b&&validate.isMobilePhone(a,b)},alpha:(a,{locale:b})=>{if(validate(a,'string'),!validator.isAlpha(a,b))throw new Error(`string: ${a} is not alpha.`)},"alpha-numeric":(a,{locale:b})=>{if(validate(a,['string','number']),!validator.isAlphanumeric(a,b))throw new Error(`value: ${a} is not alpha numeric.`)},ascii:(a)=>{if(validate(a,'string'),!validator.isAlphanumeric(a))throw new Error(`string: ${a} is not an ascii string.`)},base64:(a)=>{if(validate(a,'string'),!validator.isBase64(a))throw new Error(`string: ${a} is not a base64 string.`)},"credit-card":(a)=>{if(validate(a,['string','number']),!validator.isCreditCard(a))throw new Error(`value: ${a} is not a valid credit card number.`)},currency:(a,b)=>{if(!validator.isCurrency(a,b))throw new Error(`value: ${a} is not a valid currency with options: ${b}.`)},"data-uri":(a)=>{if(validate(a,'string'),!validator.isDataURI(a))throw new Error(`value: ${a} is not a valid data URI.`)},fqdn:(a,b)=>{if(validate(a,'string'),!validator.isFQDN(a,b))throw new Error(`value: ${a} is not a valid fully qualified domain name.`)},float:(a,b)=>{if(validate(a,'number'),!validator.isFloat(a,b))throw new Error(`value: ${a} is not a valid float.`)},hash:(a,{algorithm:b})=>{if(!validator.isFloat(a,b))throw new Error(`value: ${a} is not a valid ${b} hash.`)},"hex-color":(a)=>{if(!validator.isFloat(a))throw new Error(`value: ${a} is not a valid hex color.`)},"hex-dec":(a)=>{if(!validator.isHexadecimal(a))throw new Error(`value: ${a} is not a valid hexadecimal.`)},ip:(a,{version:b})=>{if(!validator.isIP(a))throw new Error(`value: ${a} is not a valid IP v. ${b}.`)},isbn:(a,{version:b})=>{if(!validator.isIP(a))throw new Error(`value: ${a} is not a valid ISBN v. ${b}.`)},issn:(a,b)=>{if(!validator.isISSN(a,b))throw new Error(`value: ${a} is not a valid ISSN with options ${b}.`)},isin:(a)=>{if(!validator.isISIN(a))throw new Error(`value: ${a} is not a valid ISIN (stock/security identifier).`)},iso8601:(a)=>{if(!validator.isISO8601(a))throw new Error(`value: ${a} is not a valid ISO8601.`)},isrc:(a)=>{if(!validator.isISRC(a))throw new Error(`value: ${a} is not a valid ISRC.`)},int:(a,b)=>{if(!validator.isInt(a,b))throw new Error(`value: ${a} is not a valid int with options: ${b}.`)},json:(a)=>{if(!validator.isJSON(a))throw new Error(`value: ${a} is not a valid JSON.`)},"lat-long":(a)=>{if(!validator.isLatLong(a))throw new Error(`value: ${a} is not a valid lat-long.`)},mac:(a)=>{if(!validator.isMACAddress(a))throw new Error(`value: ${a} is not a valid MAC address.`)},md5:(a)=>{if(!validator.isMD5(a))throw new Error(`value: ${a} is not a valid MD5 hash.`)},"mime-type":(a)=>{if(!validator.isMimeType(a))throw new Error(`value: ${a} is not a valid mime type.`)},"mongo-id":(a)=>{if(!validator.isMongoId(a))throw new Error(`value: ${a} is not a valid mongo-id.`)},port:(a)=>{if(!validator.isPort(a))throw new Error(`value: ${a} is not a valid port number.`)},uuid:(a)=>{if(!validator.isUUID(a))throw new Error(`value: ${a} is not a valid UUID.`)}},validate=(a,b)=>{b.name=b.name||'';const c=b.name,d=b.on||validate.on,e=b.off||validate.off,f=b.warn||validate.warn,g=b.bool||validate.bool;if((()=>('production'===process.env.NODE_ENV||e)&&(!d||!g))())return a;const h=(c)=>{let d=0,e=[];if(b.forEach((b)=>{e.push(b);try{validate(a,b)}catch(a){d++}}),d===e.length)throw new Error(`${c}: ${a} did not match any of the types: ${e.toString()}`)},i=(a)=>{let c=!1;return b.acceptedNulls&&b.acceptedNulls.forEach((b)=>{b===a&&(c=!0)}),c};try{if(Array.isArray(b))h(c);else{if(!a&&!i(a)){if(b.notRequired)return!!g||void 0;if(f&&console.warn(`Value ${c}: ${a} is required!`),g)return!1;throw new Error(`Value ${c}: ${a} is required!`)}if('string'==typeof b&&(b={type:b}),'function'==typeof b&&(b={type:b.name}),'function'==typeof b.type&&(b.type=b.type.name),['Boolean','Number','String','Object','Array','Function'].forEach((a)=>{'function'==typeof b[a]&&(b.type=b[a].name)}),!b.type)throw new Error(`${c}: ${a}.type is required`);b.extend&&b.extend(a,b);let d=validate.only?validate.only:validationsMaster;validate.extensions&&(d=Object.assign({},d,validate.extensions));const e=Object.keys(d);let h=!1;if(e.forEach((c)=>{b.type.toLowerCase()===c&&(d[c](a,b),h=!0)}),!h)throw new Error(`valitaion type: ${b.type} not found!`);return!!g||a}}catch(b){if(f&&!g)return console.warn(b),a;if(g)return f&&console.warn(b),!1;throw b}},validateFunc=(a,b,c={})=>{try{const d=c.name||a.name;if(b=Array.isArray(b)?b:[b],('production'===process.env.NODE_ENV||c.off)&&!c.on)return a(...b);if(!a)throw new Error('Missing required argument func');if('function'!=typeof a)throw new Error('First argument is not a function!');const e=a.inputModel,f=a.outputModel;e&&validateInput(b,e,a,d),f&&validate(a(...b),f)}catch(d){if(c.warn)return console.warn(d),a(...b);throw d}return a(...b)},validateInput=(a,b,c,d)=>{const e=getFuncParamNames(c);if('string'==typeof b&&(b={type:b}),'string'==typeof b.type){if(1<a.length)throw new Error(`ERROR: ${d} expected 1 parameter but received ${a.length}`);return b.name=b.name||e[0],void validate(a[0],b)}if(Array.isArray(b)){if(!Array.isArray(a))throw new Error(`ERROR: Multiple params must me passed into validateFunc as an array.`);return void b.forEach((b,c)=>{b.name=b.name||c,validate(a[c],b)})}if('object'==typeof b){if(a=a[0],'object'!=typeof a||Array.isArray(a))throw new Error(`Error: Expected a single object as the sole function param (ES6 parameter destructuring).`);const c=Object.keys(b),d=Object.keys(a);return d.forEach((a)=>{if(!matchesAny(a,e))throw new Error(`ERROR: The paramKey '${a}' does not match any of the available parameters: ${e.toString()}`)}),void c.forEach((c)=>{b[c].name=b[c].name||c,validate(a[c],b[c])})}throw new Error(`UNKNOWN ERROR: the function input model did not match the api spec.`)},type=(a,b,c)=>{if(!(()=>('production'===process.env.NODE_ENV||type.off)&&(!type.on||!type.bool))())try{return c?('object'!=typeof a&&(a={type:a}),c.type&&validate(b,c),validate(b,Object.assign({},c,a))):validate(b,a)}catch(a){if(type.warn&&!type.bool)return console.warn(a),b;if(type.bool)return type.warn&&console.warn(a),!1;throw a}};((a)=>{var b={validate,validateFunc,type,validations:validationsMaster};'undefined'!=typeof module&&module.exports?(module.exports=b,a._=b):a._=b})(this);